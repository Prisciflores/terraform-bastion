name: Bastion Infra + Ansible Bootstrap  # Nombre del workflow visible en GitHub

# ðŸ” Se ejecuta manualmente desde GitHub
on:
  workflow_dispatch:
    inputs:
      action:
        description: 'AcciÃ³n a ejecutar'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy  # Puedes elegir entre aplicar o destruir la infraestructura
permissions:
    issues: write  # âœï¸ Permite que GitHub Actions cree issues, necesario para la aprobaciÃ³n manual

env:
  TF_WORKING_DIR: ./  # Directorio donde estÃ¡ el cÃ³digo Terraform
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_DEFAULT_REGION: "us-east-1"

jobs:
  terraform:
    name: Terraform Plan & Apply
    runs-on: ubuntu-latest

    # ðŸ“¤ Define outputs del job para compartir con otros jobs
    outputs:
      bastion_ip: ${{ steps.bastion_ip.outputs.ip }}

    defaults:
      run:
        working-directory: ${{ env.TF_WORKING_DIR }}

    steps:
      # ðŸ”„ Clona el repositorio
      - name: Checkout repo
        uses: actions/checkout@v3

      # âš™ï¸ Instala Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # ðŸ§± Inicializa Terraform
      - name: Terraform Init
        run: terraform init

      # ðŸŽ¨ Verifica formato
      - name: Terraform Format
        run: terraform fmt -check

      # âœ… Valida sintaxis
      - name: Terraform Validate
        run: terraform validate

      # ðŸ” Planifica cambios
      - name: Terraform Plan
        run: terraform plan -var-file="terraform.tfvars"

      # â³ Espera aprobaciÃ³n antes del apply
      - name: Await manual approval
        if: github.event.inputs.action == 'apply'
        uses: trstringer/manual-approval@v1
        with:
         secret: ${{ secrets.GITHUB_TOKEN }}
         environment: production
         approvers: priscilaflores


      # âœ… Aplica cambios
      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        run: terraform apply -auto-approve -var-file="terraform.tfvars"

      # ðŸ’£ Destruye infraestructura
      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve -var-file="terraform.tfvars"

      # ðŸŒ Obtiene IP pÃºblica del bastiÃ³n y la exporta como output
      - name: Get Bastion IP
        if: github.event.inputs.action == 'apply'
        id: bastion_ip
        run: |
          IP=$(terraform output -raw bastion_public_ip)
          echo "ip=$IP" >> "$GITHUB_OUTPUT"  # ðŸ’¡ Output para el job (no solo variable)

  ansible:
    name: Ansible Bootstrap
    needs: terraform  # ðŸ§© Solo se ejecuta si terraform terminÃ³ bien
    if: github.event.inputs.action == 'apply'
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: ./ansible-bootstrap/playbooks  # ðŸ—‚ï¸ Donde estÃ¡ bootstrap.yml

    steps:
      # ðŸ”„ Clona el repo
      - name: Checkout repo
        uses: actions/checkout@v3

      # ðŸ§° Instala Ansible
      - name: Install Ansible
        run: sudo apt-get update && sudo apt-get install -y ansible

      # ðŸ‘€ Muestra la IP bastiÃ³n
      - name: Show Bastion IP
        run: |
          TARGET_IP=${{ needs.terraform.outputs.bastion_ip }}
          echo "Target: $TARGET_IP"

      # ðŸ” Crea la clave privada desde secret
      - name: Crear clave privada desde secret
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/priscila-key.pem
          chmod 600 ~/.ssh/priscila-key.pem

      # ðŸ§¾ Crea archivo de inventario dinÃ¡mico
      - name: Generar archivo de inventario
        run: |
          echo "[bastion]
          ${{ needs.terraform.outputs.bastion_ip }} ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/priscila-key.pem" > inventory/hosts

      # ðŸš€ Ejecuta el playbook
      - name: Ejecutar playbook
        run: ansible-playbook -i inventory/hosts bootstrap.yml
